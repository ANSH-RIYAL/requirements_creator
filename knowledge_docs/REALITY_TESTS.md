# REALITY_TESTS

## Sample Data Payloads

### Code Input Example
```python
import numpy as np
import requests
from flask import Flask

app = Flask(__name__)

@app.route('/add')
def add_numbers():
    result = np.add(5, 3)
    response = requests.get('https://api.example.com', timeout=5)
    return str(result)
```

### Analysis Result Example
```json
{
  "success": true,
  "requirements": {
    "flask": "==3.1.1",
    "numpy": "==2.2.6", 
    "requests": "==2.32.4"
  },
  "detected_libraries": ["flask", "numpy", "requests"],
  "matched_functions": {
    "flask": ["Flask", "route"],
    "numpy": ["add"],
    "requests": ["get"]
  }
}
```

### Requirements.txt Output
```
# Generated by Requirements Creator
# Exact versions based on your code analysis
flask==3.1.1
numpy==2.2.6
requests==2.32.4
```

### Frontend Inputs
- **Code Input Form:** Large textarea for Python code input with syntax highlighting
- **Auto-add Toggle:** Checkbox to automatically add missing libraries to database
- **Submit Button:** Process code analysis request
- **Input Validation:** Check for non-empty code input and basic Python syntax

## Critical User Flows
- **Primary Flow:** User inputs Python code → System analyzes imports and functions → Matches against signature database → Generates requirements.txt → Displays results
- **Error Flow:** Invalid code input → System shows validation error → User corrects and resubmits
- **Recovery Flow:** PyPI API failure → System uses local signature database → Provides partial results with warning
- **Alternative Flows:** CLI usage for batch processing, manual library addition to database

## Edge Cases
- **Input Validation:** Malformed Python code, empty input, non-Python files
- **Service Failures:** PyPI API unavailable, network timeouts, rate limiting
- **Performance Limits:** Very large codebases (>1000 files), complex dependency trees
- **Data Corruption:** Corrupted signature database files, invalid JSON data
- **Network Issues:** Intermittent connectivity, slow API responses

## Performance Test Scenarios
- **Concurrent Users:** Multiple simultaneous web interface users (2-5 users)
- **Large Data Sets:** Analysis of large Python projects (100+ files, 50+ libraries)
- **Complex Operations:** Deep dependency analysis with nested imports
- **Memory Usage:** Efficient handling of large signature databases (100+ libraries)
- **Response Times:** Sub-second analysis for typical projects (< 50 files)

## Expected Behavior on Failure
- **Backend:**
  - Return appropriate HTTP status codes (400, 500)
  - Provide clear error messages in Flask flash
  - Log detailed error information for debugging
  - Graceful fallback to partial results when possible
- **Frontend:**
  - Display user-friendly error messages
  - Show validation errors inline with form
  - Provide retry mechanisms for transient failures
  - Maintain form state during error recovery

## Quality Assurance Requirements
- **Testing Strategy:** Unit tests for each analysis component, integration tests for web interface
- **Error Handling:** Comprehensive error handling for all failure scenarios
- **Performance Monitoring:** Track analysis speed and success rates
- **User Experience:** Ensure clear feedback and helpful error messages
- **Security:** Validate and sanitize all code inputs to prevent injection attacks 